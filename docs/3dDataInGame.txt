This text got too muddled so here is the short version.

We have a spatial class which stores a model matrix, then two subclasses, one
representing obstacles call Wall, which takes on the data from a single model
inside a s64 file, and has a drawlist for visualisation, and a list of faces for
collision detection. When walls are created they can be set as either static or
dynamic (unfortunately this cannot change at runtime). The majority of walls
will be static and this means that all their face data will be transformed once
by their transformation matrix when they are created, and then when you do
collision detection with them, no transformations will need to be performed at
all. However, if they are dynamic, we probably need to calculate the inverse
transform matrix so we can use it to find the relative position of the
characters. We can just make it that spatials can cache their inverse matrix
like they cache the normal one.

Character spatials on the other hand, can be duplicated etc, and all the little
meshes are all just made a part of the single spatial. I think basically when
you load a s64 file for character data, rather than resulting in the creation of
a character spatial, you get some kind of animation object which can be used to
render an arbitrary frame of animation at any time subject to the current
matrices in play etc.

Since Walls are basically just loaded at the start then left to their own
devices, we will just store a plain array and count of them, but for characters
since they are likely to be popping in and out of existence more regularly,
they will be stored in an unordered list that maintains contiguous entries.
One exception to the list's disorder is that the player character should be the
first entry (since nothing is before it it can't get moved unless the player
character is deleted which should not happen).

So, the loading of this data from a s64 file will be callback based, we get one
callback to tell us the number of meshes, then a callback per mesh, then 
callbacks for animations etc etc, and we get some kind of state object which is
passed to them all. Actually rather than passing a million callback functions
lets just make it there is an interface and that also serves as your state
object.